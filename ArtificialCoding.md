# Professional development will coexist with Layman Prototyping

There are heated discussions triggered by the newer and newer layers of artificial intelligence: gpt3.5 then gpt4, o1 and now o3 models. Yes they can generate code but still you need **the massive shoulders of giants**.
The code is not a singular invention of one person but a focused construct of small additions of the all contributors. Not only that but there is a Darwinian filtering where only best libraries and systems get support for new developers effort.

Of course we will have such admirable contributions from AI.
Not only that but these contributions can be reused by any developer if published as open source or at least behind a paywall API. That's why we encapsulate work. Heck, we could encapsulate extraterrestrial technology without knowing anything about how is created as long as we know how to call it and use the outcomes properly. We already know how to use nature from a long time ago without knowing how it works: fire, alcohol, clothes.

There are 3 things that are enough to be able to control any information system: 1) **some univocal deterministic languages** to be used to accumulate knowledge for the 2) **platform code** that already exists (magically) and 3) **the new prototyping code**. Prototyping code could be equivocal (so even human language) since the result will have only local or minimal impact: hence low-code or no-code systems.

1) **Univocal Deterministic Language** - We need a way to formally encode some steps/algorithms.
   - One attribute of this code is that succumbs to the **thinking slow** paradigm. Is an entirely rational, deterministic, inspectable, debuggable way of processing thoughts. It follows formal logical rules.
   - An equivocal language is indeterministic, **thinking fast**/intuitively/dependent of the neural network and is not a good tool for platform code. But could be good for the prototyping code.
2) **Platform Code - Reviewed and Trusted Code** - usable as Library or System
   - This code is written and certified/assumed by a person or AI. There is effort in reading code and as consumers of code we don't want to always be in a state of reading and understand **entire **code. We need to have some assumptions/conventions or stable ground or platform. The platform is accessible via functions/classes/libraries/api and contains the most used patterns hidden under an interface. As times pass, the usage increases and the number of open bugs asymptotically reach zero. This way the trust in the platform code grows.
   - There is a formal process where more and more code gets delivered under the platform code and the same process can be used for AI code as well: tests, reviews, bug fixing, maturity.
3) **Prototyping Code**
   - This code is written/generated by a person or AI and should be just glue code to test ideas not for libraries nor systems.
   - Can be written by non technical people since it covers just the outmost layer.
   - Best way to write it is in Notebook style: Jupyter Notebook or the like using a programming language at hand. Nowadays typed languages advanced enough to have type inference but typed enough to have much better formal autocomplete. Anyway autocomplete now can also come from AI but more in the form of hints and not formal suggestions. Typescript has a good balance between the two.
 
The conclusion is that o1 or o3 coding capabilities can be used in two ways: for library/system coding (real/professional audited code) but also for prototyping ideas. There is room for both.
 
The professional developer will coexist with the power user that prototypes.
 
DNA might be viewed as the platform code while the brain is the prototype code trained by the environment and experiences.
We cannot say that the brain will
  1) not need the DNA platform code
  2) use a very very old platform code that is never updated
  3) recreate the platform code from scratch from first principles
Or should we say?

